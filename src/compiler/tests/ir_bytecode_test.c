#include <stdio.h>
#include <stdlib.h>
#include "../ir/ir.h"
#include "../../vm/bytecode/bytecode.h"
#include "../emitter/ir_to_bytecode.h"

int main() {
    printf("=== He³ IR and Bytecode Writer Test ===\n\n");
    
    // Create bytecode writer
    BytecodeWriter* writer = bytecode_writer_create(1024);
    if (!writer) {
        printf("Failed to create bytecode writer\n");
        return 1;
    }
    
    // Create IR builder
    IRBuilder* builder = ir_builder_create();
    if (!builder) {
        printf("Failed to create IR builder\n");
        bytecode_writer_destroy(writer);
        return 1;
    }
    
    // Create a simple function
    IRFunction* function = ir_builder_create_function(builder, "test_function", 0x12345678);
    if (!function) {
        printf("Failed to create function: %s\n", ir_builder_get_error(builder));
        ir_builder_destroy(builder);
        bytecode_writer_destroy(writer);
        return 1;
    }
    
    // Create entry block
    IRBlock* entry_block = ir_builder_create_block(builder, "entry");
    if (!entry_block) {
        printf("Failed to create entry block: %s\n", ir_builder_get_error(builder));
        ir_builder_destroy(builder);
        bytecode_writer_destroy(writer);
        return 1;
    }
    
    ir_builder_set_current_block(builder, entry_block);
    
    // Create some test instructions
    printf("Creating test instructions...\n");
    
    // Load constant 42
    IRInstruction* load_const = ir_builder_create_instruction(builder, IR_LOAD_CONST);
    if (load_const) {
        ir_instruction_add_operand(load_const, ir_builder_create_i64_value(42));
        ir_instruction_set_result(load_const, ir_builder_create_temp_value(builder, IR_VALUE_I64));
        ir_builder_add_instruction(builder, load_const);
    }
    
    // Load constant 10
    IRInstruction* load_const2 = ir_builder_create_instruction(builder, IR_LOAD_CONST);
    if (load_const2) {
        ir_instruction_add_operand(load_const2, ir_builder_create_i64_value(10));
        ir_instruction_set_result(load_const2, ir_builder_create_temp_value(builder, IR_VALUE_I64));
        ir_builder_add_instruction(builder, load_const2);
    }
    
    // Add them together
    IRInstruction* add = ir_builder_create_instruction(builder, IR_ADD);
    if (add) {
        ir_instruction_add_operand(add, ir_builder_create_temp_value(builder, IR_VALUE_I64));
        ir_instruction_add_operand(add, ir_builder_create_temp_value(builder, IR_VALUE_I64));
        ir_instruction_set_result(add, ir_builder_create_temp_value(builder, IR_VALUE_I64));
        ir_builder_add_instruction(builder, add);
    }
    
    // Return the result
    IRInstruction* return_val = ir_builder_create_instruction(builder, IR_RETURN_VAL);
    if (return_val) {
        ir_instruction_add_operand(return_val, ir_builder_create_temp_value(builder, IR_VALUE_I64));
        ir_builder_add_instruction(builder, return_val);
    }
    
    // Print the IR
    printf("\n=== Generated IR ===\n");
    ir_print_function(function);
    
    // Create IR to bytecode translator
    IRToBytecodeTranslator* translator = ir_to_bytecode_translator_create(writer);
    if (!translator) {
        printf("Failed to create translator\n");
        ir_builder_destroy(builder);
        bytecode_writer_destroy(writer);
        return 1;
    }
    
    // Translate IR to bytecode
    printf("\n=== Translating IR to Bytecode ===\n");
    if (!ir_to_bytecode_translate_function(translator, function)) {
        printf("Translation failed: %s\n", ir_to_bytecode_translator_get_error(translator));
        ir_to_bytecode_translator_destroy(translator);
        ir_builder_destroy(builder);
        bytecode_writer_destroy(writer);
        return 1;
    }
    
    // Print bytecode
    printf("\n=== Generated Bytecode ===\n");
    bytecode_writer_print_disassembly(writer);
    
    // Print hex dump
    printf("\n=== Hex Dump ===\n");
    bytecode_writer_print_hex(writer);
    
    // Test string table
    printf("\n=== String Table Test ===\n");
    uint32_t str1_id = bytecode_writer_emit_string(writer, "Hello, World!");
    uint32_t str2_id = bytecode_writer_emit_string(writer, "He³ Language");
    uint32_t str3_id = bytecode_writer_emit_string(writer, "Hello, World!"); // Duplicate
    
    printf("String 1 ID: %u\n", str1_id);
    printf("String 2 ID: %u\n", str2_id);
    printf("String 3 ID: %u (should be same as string 1)\n", str3_id);
    
    printf("String 1: %s\n", string_table_get_string(writer->strings, str1_id));
    printf("String 2: %s\n", string_table_get_string(writer->strings, str2_id));
    printf("String 3: %s\n", string_table_get_string(writer->strings, str3_id));
    
    printf("String table count: %u\n", string_table_get_count(writer->strings));
    printf("String table total size: %u bytes\n", string_table_get_total_size(writer->strings));
    
    // Clean up
    ir_to_bytecode_translator_destroy(translator);
    ir_builder_destroy(builder);
    bytecode_writer_destroy(writer);
    
    printf("\n=== Test Complete ===\n");
    return 0;
}
